<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac 上编译 CUDA+Tensorflow]]></title>
    <url>%2F2019%2F04%2F29%2F1556506356%2F</url>
    <content type="text"><![CDATA[MacOS High Sierra Version 10.13.6（17G6030) NVIDIA Web Driver 387.10.10.10.40.124 CUDA Toolkit 10.0 cuDNN 7.5 NVIDIA Collective Communications Library (NCCL) 2.4.2-1 Python 3.6.8 Anaconda 2019.3 Xcode 9.4 Command Line Tool for Xcode 9.4 Jdk 8u211 Bazel 0.19.2 Python Version Status Branch 3.6.8 r1.12 3.6.8 r1.12.2 3.6.8 r1.13 3.6.8 r1.14 3.7 + All 编译前准备 1.禁用 System Integrity Protection（SIP） 2.安装 Xcode 9.4 3.安装 Anaconda 并安装 Python 3.6.8 4.安装 NVIDIA Runtime 1.安装 NVIDIA Web Driver 2.安装 CUDA Toolkit 3.安装 cuDNN 4.安装 NVIDIA Collective Communications Library (NCCL) 5.使用 Homebrew 安装库 1.安装 coreutils 2.安装 openmp 6.安装 Jdk 8 7.安装 Bazel 禁用 SIP打开终端输入，关闭系统完整性保护1csrutil disable; reboot 安装 Xcode 9.4下载 Xcode9.4.xip苹果开发者下载平台Xcode 9.4随后解压拷贝至 Applications, 打开终端运行将 Xcode 9.4 设置为默认1sudo xcode-select -s /Applications/Xcode9.4.app 若你之前安装过其他版本的Xcode可能会安装匹配的Command Line Tool，需要更换其版本Command Line Tool for 9.4 安装 Anaconda在官网下载 Anaconda 并安装Anaconda 下载页面官网安装文档Anaconda 安装向导安装完成后，打开终端更换Python版本为3.6.81conda install python=3.6.8 随后，输入 Python 验证是否为3.6.8版本12345(base) iMac:~ admin$ pythonPython 3.6.8 |Anaconda, Inc.| (default, Dec 29 2018, 19:04:46) [GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; 安装 NVIDIA Runtime 1.安装 NVIDIA Web Driver 2.安装 CUDA Toolkit 3.安装 cuDNN 4.安装 NVIDIA Collective Communications Library (NCCL) 安装 Web Driver选择与自己系统匹配的版本，下载下来并安装下载地址 安装 CUDA Toolkit在 archive 选择 CUDA Toolkit 10.0下载CUDA Toolkit Archive下载后安装，并配置变量到 .bash_profile1234export CUDA_HOME=/usr/local/cudaexport DYLD_LIBRARY_PATH=/usr/local/cuda/lib:/usr/local/cuda/extras/CUPTI/libexport LD_LIBRARY_PATH=$DYLD_LIBRARY_PATHPATH=$DYLD_LIBRARY_PATH:$PATH:/Developer/NVIDIA/CUDA-10.0/bin 随后输入 nvcc -V 测试是否配置正确12345(base) iMac:~ admin$ nvcc -Vnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2018 NVIDIA CorporationBuilt on Sat_Aug_25_21:08:56_CDT_2018Cuda compilation tools, release 10.0, V10.0.130 检测 CUDA 是否能正常工作，切换目录到 CUDA Samples1cd /Developer/NVIDIA/CUDA-10.0/samples/1_Utilities/deviceQuery 若出现以下情况，请说明 Command Line Tool 版本不受支持，请更换版本1nvcc fatal : The version ('8.0') of the host compiler ('clang') is not supported 安装 cuDNN下载 cuDNN 并解压到 CUDA 目录下，注意选择对应的 CUDA 版本cuDNN 下载地址下载后解压到 CUDA 目录1234567891011(base) iMac:cuda admin$ tree.├── NVIDIA_SLA_cuDNN_Support.txt├── include│ └── cudnn.h└── lib ├── libcudnn.7.dylib ├── libcudnn.dylib -&gt; libcudnn.7.dylib └── libcudnn_static.a2 directories, 5 files 安装 NCCL下载 NCCLNCCL 下载地址下载后解压，并配置软链接，注意替换成自己下载的版本123456789brew install xzxz -d nccl_&lt;verison&gt;+cuda10.0_x86_64.txztar xvf nccl_&lt;verison&gt;+cuda10.0_x86_64.tarsudo mkdir -p /usr/local/ncclcd nccl_&lt;version&gt;+cuda10.0_x86_64sudo mv * /usr/local/ncclsudo mkdir -p /usr/local/include/third_party/ncclsudo ln -s /usr/local/nccl/include/nccl.h /usr/local/include/third_party/nccl Homebrew 部分安装 coreutils1brew install coreutils 安装 openmp1brew install cliutils/apple/libomp 安装 Jdk下载 Jdk 并根据向导安装 (解决Bazel安装问题，请下载JDK8)Jdk 下载地址验证 Jdk 是否安装成功12345(base) iMac:cuda admin$ java -versionjava version "1.8.0_211"Java(TM) SE Runtime Environment (build 1.8.0_211-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)(base) iMac:cuda admin$ 安装 Bazel使用新版本的 Bazel 可能会导致编译失败，现在需要下载低版本（0.19.2）的 Bazel 来进行编译 Bazel 0.19.2 下载安装完成后配置环境变量1export PATH="$PATH:$HOME/bin" 环境变量的配置根据 Bazel 安装的位置来进行确认，这里默认安装的是用户的主目录 激活环境变量打开控制台输入1source .bash_profile 开始编译 1.下载源码 2.编译配置 3.开始编译 1.Bazel 编译 2.PIP 包编译 下载 Tensorflow 源码从 github 上下载 tensorflow的源码12git clone https://github.com/tensorflow/tensorflow.gitcd tensorflow 默认使用 master 分支，如需要调整成其他分支，请如下配置（r1.14以上版本 Bazel 需要 0.24 以上如需编译请更换 Bazel 版本）1git checkout branch_name # r1.9, r1.10, etc. 由于 Mac 不支持 align(sizeof(T)) 所以需要将他们移除123sed -i -e "s/ __align__(sizeof(T))//g" tensorflow/core/kernels/concat_lib_gpu_impl.cu.ccsed -i -e "s/ __align__(sizeof(T))//g" tensorflow/core/kernels/depthwise_conv_op_gpu.cu.ccsed -i -e "s/ __align__(sizeof(T))//g" tensorflow/core/kernels/split_lib_gpu.cu.cc 配置编译打开控制台输入1./configure 根据提示进行配置，除了是否使用 CUDA Support 其他都默认写 No123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869(base) iMac:tensorflow admin$ ./configureWARNING: --batch mode is deprecated. Please instead explicitly shut down your Bazel server using the command "bazel shutdown".You have bazel 0.19.2 installed.Please specify the location of python. [Default is /Users/admin/anaconda3/bin/python]: Found possible Python library paths: /Users/admin/anaconda3/lib/python3.7/site-packagesPlease input the desired Python library path to use. Default is [/Users/admin/anaconda3/lib/python3.7/site-packages]Do you wish to build TensorFlow with XLA JIT support? [y/N]: nNo XLA JIT support will be enabled for TensorFlow.Do you wish to build TensorFlow with OpenCL SYCL support? [y/N]: nNo OpenCL SYCL support will be enabled for TensorFlow.Do you wish to build TensorFlow with ROCm support? [y/N]: nNo ROCm support will be enabled for TensorFlow.Do you wish to build TensorFlow with CUDA support? [y/N]: yCUDA support will be enabled for TensorFlow.Please specify the CUDA SDK version you want to use. [Leave empty to default to CUDA 10.0]: Please specify the location where CUDA 10.0 toolkit is installed. Refer to README.md for more details. [Default is /usr/local/cuda]: Please specify the cuDNN version you want to use. [Leave empty to default to cuDNN 7]: 7.5Please specify the location where cuDNN 7 library is installed. Refer to README.md for more details. [Default is /usr/local/cuda]: /Developer/NVIDIA/CUDA-10.0Please specify a list of comma-separated Cuda compute capabilities you want to build with.You can find the compute capability of your device at: https://developer.nvidia.com/cuda-gpus.Please note that each additional compute capability significantly increases your build time and binary size. [Default is: 3.5,7.0]: 6.1Do you want to use clang as CUDA compiler? [y/N]: nnvcc will be used as CUDA compiler.Please specify which gcc should be used by nvcc as the host compiler. [Default is /usr/bin/gcc]: Do you wish to build TensorFlow with MPI support? [y/N]: No MPI support will be enabled for TensorFlow.Please specify optimization flags to use during compilation when bazel option "--config=opt" is specified [Default is -march=native -Wno-sign-compare]: Would you like to interactively configure ./WORKSPACE for Android builds? [y/N]: Not configuring the WORKSPACE for Android builds.Preconfigured Bazel build configs. You can use any of the below by adding "--config=&lt;&gt;" to your build command. See .bazelrc for more details. --config=mkl # Build with MKL support. --config=monolithic # Config for mostly static monolithic build. --config=gdr # Build with GDR support. --config=verbs # Build with libverbs support. --config=ngraph # Build with Intel nGraph support. --config=dynamic_kernels # (Experimental) Build kernels into separate shared objects.Preconfigured Bazel build configs to DISABLE default on features: --config=noaws # Disable AWS S3 filesystem support. --config=nogcp # Disable GCP support. --config=nohdfs # Disable HDFS support. --config=noignite # Disable Apacha Ignite support. --config=nokafka # Disable Apache Kafka support. --config=nonccl # Disable NVIDIA NCCL support.Configuration finished 其中 Additional compute capability significantly GPU计算能力需要到官网找到你的设备，然后填写数值或者安装 CUDA-Z查看 点击查看文档地址 开始编译先使用 Bazel 进行编译 1bazel build --config=cuda --config=opt --action_env PATH --action_env LD_LIBRARY_PATH --action_env DYLD_LIBRARY_PATH //tensorflow/tools/pip_package:build_pip_package 下图为开始编译 编译的时间需要根据不同的情况确定，这里大概花了1小时左右的时间，显示编译完成后，开始编译pip安装包 Bazel 编译完成后，开始编译PIP安装包 1./bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg 上图编译完成后会在 /tmp/tensorflow_pkg 目录下生成 whl 文件，随后使用pip安装即可]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python运算符重载和特殊方法]]></title>
    <url>%2F2019%2F04%2F15%2F1555335611%2F</url>
    <content type="text"><![CDATA[数据结构与算法 [面向对象编程] 操作系统: Windows 10 Anaconda 2019.3 Python 3.7.1 概念Python的内置类为许多操作提供了自然的语义。比如，a + b 语句可以调用数值类型语句，也可以连续序列类型。但是对于新的类来说，“+” 操作符是未定义的，所以就需要 操作符重载 (Operator Overloading) 技术来定义它 特殊方法实现的重载操作 常见的语法 特别方法的形式 a + b a.__add__(b) 或者 b.__radd__(a) a - b a.__sub__(b) 或者 b.__rsub__(a) a * b a.__mul__(b) 或者 b.__rmul__(a) a / b a.__truediv__(b) 或者 b.__rtruediv__(a) a // b a.__floordiv__(b) 或者 b.__rfloordiv__(a) a % b a.__mod__(b) 或者 b.__rmod__(a) a ** b a.__pow__(b) 或者 b.__rpow__(a) a &lt;&lt; b a.__lshift__(b) 或者 b.__rlshift__(a) a &gt;&gt; b a.__rshift__(b) 或者 b.__rrshift__(a) a &amp; b a.__and__(b) 或者 b.__rand__(a) a ^ b a.__xor__(b) 或者 b.__rxor__(a) a &#124; b a.__or__(b) 或者 b.__ror__(a) a += ba -= ba *= b… a.__iadd__(b)a.__isub__(b)a.__imul__(b)… + a a.__pos__(b) - a a.__neg__(b) ~ a a.__invert__(b) abs(a) a.__abs__(b) a &lt; b a.__lt__(b) a &lt;= b a.__le__(b) a &gt; b a.__gt__(b) a &gt;= b a.__ge__(b) a == b a.__eq__(b) a != b a.__ne__(b) vin a a.__contains__(v) a [k] a.__getitem__(k) a [k] = v a.__setitem__(k,v) del a [k] a.__delitem__(k) a(arg1, arg2, ···) a.__call__(arg1, arg2, ···) len(a) a.__len__() hash(a) a.__hash__() iter(a) a.__iter__() next(a) a.__next__() bool(a) a.__bool__() float(a) a.__float__() int(a) a.__int__() repr(a) a.__repr__() reversed(a) a.__reversed__() str(a) a.__str__() 演示实例我们创建一个 Vector 的多维向量类的实现方法，代表了多维空间中的向量的坐标，如坐标&lt;5, -2, 3&gt;相加坐标&lt;1, 4, 2&gt;的结果是使用列表进行计算得到&lt;5, -2, 3, 1, 4, 2&gt;, 我们现在将使用运算符重载来实现我们的需求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Vector: """表示多维数据集里的向量""" def __init__(self, d): """创建D维度向量""" self.__coords = [0] * d def __len__(self): """返回向量维数""" return len(self.__coords) def __getitem__(self, j): """返回下标j的向量""" return self.__coords[j] def __setitem__(self, j, val): """设置下标j的向量值""" self.__coords[j] = val def __add__(self, other): """返回向量计算和""" if len(self) != len(other): raise ValueError('维度必须一致') result = Vector(len(self)) for j in range(len(self)): result[j] = self[j] + other[j] return result def __eq__(self, other): """返回坐标是否相同""" return self.__coords == other.__coords def __ne__(self, other): """返回坐标是否不同""" return not self == other def __str__(self): """生成表示向量的字符""" return '&lt;' + str(self.__coords)[1: -1] + "&gt;"if __name__ == '__main__': v = Vector(5) v[1] = 23 # &lt;0, 23, 0, 0, 0&gt; v[-1] = 45 # &lt;0,23, 0, 0, 45&gt; print(v[4]) u = v + v # &lt;0, 46, 0, 0, 90&gt; total = 0 for entry in v: total += entry Demo on Github : Python运算符重载和特殊方法]]></content>
      <categories>
        <category>Data Structures &amp; Algorithms</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彩虹六号战绩查询开发文档]]></title>
    <url>%2F2019%2F03%2F10%2F1552210325%2F</url>
    <content type="text"><![CDATA[此文档为彩虹六号战绩查询开发版文档 第一版 仅适用于项目维护开发人员 更新时间 2019年3月11日 API 说明目前此项目的API分为三类分别是用户信息类 , 游戏数据类 , 数据更新类 用户信息当前API可实现 根据用户名获取ID , 查询用户的彩虹六号启动信息 , 查询用户的其他平台 根据用户名获取ID请求地址: https://api.forgiveher.cn/rainbow/user/get/id 支持格式: JSON HTTP 请求方式: GET 请求参数: 必选 范围及类型 说明 name true string 需要查询的用户名 platform true string 查询所指定的平台范围 , 当前平台有 Uplay , Psn, Xbl 返回示例:123456789101112&#123; "profiles": [ &#123; "profileId": "6499575f-44f1-4d34-a521-8572c7ad6a19", "userId": "6499575f-44f1-4d34-a521-8572c7ad6a19", "platformType": "uplay", "idOnPlatform": "6499575f-44f1-4d34-a521-8572c7ad6a19", "nameOnPlatform": "Python.org" &#125; ], "success": true&#125; 返回字段说明: 类型 说明 profiles json 用户平台的数组信息 prorfileId string 用户的 profileId 与 userId 一致 userId string 用户的 userId 与 profileId 一致 platformType string 查询的用户所在的平台 idOnPlatform string 用户在平台上的 ID nameOnPlatform string 用户在平台上的用户名 success bool 查询请求是否成功 查询用户的彩虹六号启动信息请求地址: https://api.forgiveher.cn/rainbow/user/get/application 支持格式: json HTTP 请求方式: GET 请求参数: 必选 范围及类型 说明 profile true string 需要查询的用户的profile(userId) platform true string 查询所指定的平台范围 , 当前平台有 Uplay , Psn, Xbl 返回示例: 123456&#123; "success": true, "first": "2018-08-02 04:02:40", "last": "2018-08-10 20:05:18", "count": 29&#125; 返回字段说明: 类型 说明 success bool 查询请求是否成功 first string 用户第一次启动彩虹六号的时间 last string 用户最后一次启动彩虹六号的时间 count int 用户启动彩虹六号的次数 查询用户其他平台账号请求地址: https://api.forgiveher.cn/rainbow/user/get/platform 支持格式: json HTTP 请求方式: GET 请求参数: 必选 范围及类型 说明 profile true string 需要查询的用户的profile(userId) 返回示例: 12345678910111213141516171819&#123; "profiles": [ &#123; "profileId": "bc5c03a4-2327-4f7a-a791-04c12debe3dd", "userId": "bc5c03a4-2327-4f7a-a791-04c12debe3dd", "platformType": "uplay", "idOnPlatform": "bc5c03a4-2327-4f7a-a791-04c12debe3dd", "nameOnPlatform": "GoLang.org" &#125;, &#123; "profileId": "cee54733-05d2-4d5b-bec9-b6e4db8a586c", "userId": "bc5c03a4-2327-4f7a-a791-04c12debe3dd", "platformType": "steam", "idOnPlatform": "76561198864553797", "nameOnPlatform": "76561198864553797" &#125; ], "success": true&#125; 返回字段说明: 类型 说明 profiles json 用户平台的数组信息 prorfileId string 用户的 profileId 与 userId 一致 userId string 用户的 userId 与 profileId 一致 platformType string 查询的用户所在的平台 idOnPlatform string 用户在平台上的 ID nameOnPlatform string 用户在平台上的用户名 success bool 查询请求是否成功 游戏数据当前API可实现 获取用户的 PVE 最高得分信息 , 获取用户的 PVP 最高得分信息 获取用户 PVE 最高得分请求地址: https://api.forgiveher.cn/rainbow/pve/score 支持格式: json HTTP 请求方式: GET 请求参数: 必选 范围及类型 说明 profile true string 需要查询的用户的profile(userId) platform true string 查询所指定的平台范围 , 当前平台有 Uplay , Psn, Xbl 返回示例: 12345678910&#123; "success": true, "userID": "d065fc0e-0d1b-45de-8267-0ab87bfaec56", "nzgl": 943, "kngl": 0, "ptgl": 20000, "nzhz": 2680, "knhz": 2818, "pthz": 2649&#125; 返回字段说明: 类型 说明 success bool 查询请求是否成功 userID string 所查询用户的userId nzgl int 用户拟真孤狼模式的得分 kngl int 用户困难孤狼模式的得分 ptgl int 用户普通孤狼模式的得分 nzhz int 用户拟真合作模式的得分 knhz int 用户困难合作模式的得分 pthz int 用户普通合作模式的得分 获取用户 PVP 最高得分请求地址: https://api.forgiveher.cn/rainbow/pvp/score 支持格式: json HTTP 请求方式: GET 请求参数: 必选 范围及类型 说明 profile true string 需要查询的用户的profile(userId) platform true string 查询所指定的平台范围 , 当前平台有 Uplay , Psn, Xbl 返回示例: 1234567&#123; "success": true, "userID": "d065fc0e-0d1b-45de-8267-0ab87bfaec56", "boom": 7492, "secure": 5880, "hostage": 8194&#125; 返回字段说明: 类型 说明 success bool 查询请求是否成功 userID string 所查询用户的userId boom int 用户炸弹模式的得分 secure int 用户肃清威胁的得分 hostage int 用户保护人质的得分 数据更新当前API可实现 更新用户的 PVP 数据 , 更新用户的 PVE 数据 , 更新用户的 Rank 数据 更新用户的 Rank 数据请求地址: https://api.forgiveher.cn/rainbow/rank/update 支持格式: json HTTP 请求方式: GET 请求参数: 必选 范围及类型 说明 profile true string 需要查询的用户的profile(userId) platform true string 查询所指定的平台范围 , 当前平台有 Uplay , Psn, Xbl 返回示例: 1234567&#123; "results": &#123; "ncsa": "&#123;\"success\": true, \"region\": \"ncsa\", \"msg\": \"[Update] d065fc0e-0d1b-45de-8267-0ab87bfaec56 ncsa rank data.\", \"time\": 1552306603.9727173&#125;", "emea": "&#123;\"success\": true, \"region\": \"emea\", \"msg\": \"[Update] d065fc0e-0d1b-45de-8267-0ab87bfaec56 emea rank data.\", \"time\": 1552306605.8566387&#125;", "apac": "&#123;\"success\": true, \"region\": \"apac\", \"msg\": \"[Update] d065fc0e-0d1b-45de-8267-0ab87bfaec56 apac rank data.\", \"time\": 1552306608.2685604&#125;" &#125;&#125; 返回字段说明: 类型 说明 results json 用户排位信息更新结果数组 ncsa json 用户美服排位更新结果信息 emea json 用户欧服排位更新结果信息 apac json 用户亚服排位更新结果信息 success bool 数据更新请求是否成功 region string 用户所在的游戏区服 msg string 查询的结果信息 time float 查询数据的时间 更新用户的 PVP 数据请求地址: https://api.forgiveher.cn/rainbow/pvp/update 支持格式: json HTTP 请求方式: GET 请求参数: 必选 范围及类型 说明 profile true string 需要查询的用户的profile(userId) platform true string 查询所指定的平台范围 , 当前平台有 Uplay , Psn, Xbl 返回示例: 12345&#123; "success": true, "msg": "[Update] bdd408df-c8fc-4304-a3cf-f070c988b610 pvp data.", "time": 1552389757.41531&#125; 返回字段说明: 类型 说明 success bool 数据更新请求是否成功 msg string 查询的结果信息 time float 查询数据的时间 更新用户的 PVE 数据请求地址: https://api.forgiveher.cn/rainbow/pve/update 支持格式: json HTTP 请求方式: GET 请求参数: 必选 范围及类型 说明 profile true string 需要查询的用户的profile(userId) platform true string 查询所指定的平台范围 , 当前平台有 Uplay , Psn, Xbl 返回示例: 12345&#123; "success": true, "msg": "[Update] bdd408df-c8fc-4304-a3cf-f070c988b610 pve data.", "time": 1552389894.4672287&#125; 返回字段说明: 类型 说明 success bool 数据更新请求是否成功 msg string 查询的结果信息 time float 查询数据的时间]]></content>
      <categories>
        <category>Wiki</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[名华慕课App算法解密过程以及软件实现]]></title>
    <url>%2F2018%2F12%2F16%2F1544945520%2F</url>
    <content type="text"><![CDATA[测试环境 Windows 10 x64 Fiddler 5.0.20182.28034 ApkIDE 3.5.0.0 测试样本 名华慕课 Android 版 1.0.3 Python 3.6.8 捕获数据包使用 Fiddler 截获手机客户端的 HTTP 封包 , 如何使用 Fiddler 截获手机封包请自行 Google 这里不做过多阐释 request12345678910POST http://api.mooc.minghuaetc.com/v1 HTTP/1.1Cookie: moocvk=*************;moocsk=**************;Content-Length: 89Content-Type: application/x-www-form-urlencodedHost: api.mooc.minghuaetc.comConnection: Keep-AliveUser-Agent: Mozilla/5.0 (Linux; U; Android 8.0.0; en-gb; SM-G9650 Build/R16NW) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1Accept-Encoding: gzipcmd=course.subject&amp;client=chinamoocs&amp;level=2&amp;spoc=1&amp;sign=125d379b0b53f2c43214721ad3732e4d 出于安全考虑已经将 Cookies 信息做处理实际测试中以实际值为准 , 可以看到提交的字段有 cmd、client、level、spoc、sign 搜索方法打开 ApkIDE 加载名华慕课安卓客户端 , 然后使用全局搜索 cmd 字段内容 course.subject 可以看到使用了 course.subject 的有两个类 com/wisedu/mooccloud/mhaetc/phone/ui/HomeActivitycom/wisedu/mooccloud/mhaetc/phone/service/ZhiTuService 根据类名推测分析 , 我们需要进行分析的为 HomeActivity 查看其 Java 源代码 , 静态分析函数 eP 发现 sign 是由 localObject2 赋值 , localObject2 由 localObject1 赋值 , localObject1 由函数 ig.d赋值 , 于是继续追踪函数 追踪函数查看 ig.d 发现 return 处由另外函数 aE 赋值 , 继续查看 aE 函数 , 其中又使用了 e 函数进行复制 发现是一个 摘要算法 MD5 的加密 sign 算法解密结合前面的 Java 源码中的函数 eP , 静态分析出传递给 ig.d 方法的参数为 POST 除 sign 字段的所有字段值加上一个常量值 xF3m1m4CrvQd3VsfsEpIf6s0CPWT7sJu 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void eP() &#123; RequestParams localRequestParams = new RequestParams(); localRequestParams.setHeader("Cookie", hz.a(this.pw)); localRequestParams.addBodyParameter("cmd", "course.subject"); localRequestParams.addBodyParameter("client", "chinamoocs"); localRequestParams.addBodyParameter("level", "2"); localRequestParams.addBodyParameter("spoc", String.valueOf(gt.c(this.pE))); Object localObject1 = new ArrayList(); ((List)localObject1).add("course.subject"); ((List)localObject1).add("chinamoocs"); ((List)localObject1).add("2"); ((List)localObject1).add(String.valueOf(gt.c(this.pE))); ((List)localObject1).add("xF3m1m4CrvQd3VsfsEpIf6s0CPWT7sJu"); Object localObject2 = ""; try &#123; localObject1 = ig.d((List)localObject1); localObject2 = localObject1; &#125; catch (Exception localException) &#123; for (;;) &#123;&#125; &#125; localRequestParams.addBodyParameter("sign", ((String)localObject2).toLowerCase()); new HttpUtils().send(HttpRequest.HttpMethod.POST, gr.pn, localRequestParams, new RequestCallBack() &#123; public void onFailure(HttpException paramAnonymousHttpException, String paramAnonymousString) &#123;&#125; public void onStart() &#123;&#125; public void onSuccess(ResponseInfo&lt;String&gt; paramAnonymousResponseInfo) &#123; hz.a(paramAnonymousResponseInfo, HomeActivity.this.pw); ie.d(HomeActivity.this.TAG, "我的课程 返回： " + (String)paramAnonymousResponseInfo.result); hz.a(paramAnonymousResponseInfo, HomeActivity.this.pw); try &#123; JSONObject localJSONObject = new org/json/JSONObject; localJSONObject.&lt;init&gt;((String)paramAnonymousResponseInfo.result); String str = localJSONObject.optString("code"); localJSONObject.optString("message", "服务器或网络出现错误，请稍后再试~"); if ("000000".equals(str)) &#123; hh.c(localJSONObject.getJSONObject("result").optJSONArray("subjects"), HomeActivity.this.pw.qH); hz.a(paramAnonymousResponseInfo, HomeActivity.this.pw); &#125; return; &#125; catch (JSONException paramAnonymousResponseInfo) &#123; for (;;) &#123; paramAnonymousResponseInfo.printStackTrace(); &#125; &#125; &#125; &#125;); &#125; 重新组合文本并使用 md5 加密 , 可以得出 HTTP 请求中一致的 sign 字段值 到此 sign 算法解密结束 password 算法解密根据 Fiddler 截获的封包中 , 发现登录的 HTTP 封包如下 request12345678910POST http://api.mooc.minghuaetc.com/v1 HTTP/1.1Cookie: moocvk=**************;Content-Length: 121Content-Type: application/x-www-form-urlencodedHost: api.mooc.minghuaetc.comConnection: Keep-AliveUser-Agent: Mozilla/5.0 (Linux; U; Android 8.0.0; en-gb; SM-G9650 Build/R16NW) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1Accept-Encoding: gzipcmd=sys.login.no&amp;client=chinamoocs&amp;orgid=**&amp;user=**&amp;password=dk******h1DI%3D%0A&amp;sign=*********************** 出于安全考虑已经 Cookies 信息和用户凭据字段做处理实际测试中以实际值为准 , 将其 URLDecode 后 dk**h1DI%3D%0A为 dk**h1DI= 因此推测是一串 Base64 编码的字符串 , 先对其进行直接解码后发现为乱码 , 因此这不是一个单纯的 Base64 编码与百度贴吧客户端不同 , 再次搜索方法 , 找到位于类 com/wisedu/mooccloud/mhaetc/phone/ui/UnifyLucherActivity 中的 as函数 , 静态分析发现 , password 是由 localObject1 赋值 , localObject1 是由函数 ig.aF 赋值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private void as(final String paramString) &#123; final String str1 = this.uC.getText().toString(); final String str2 = this.uD.getText().toString(); Object localObject1 = ig.aF(str2); RequestParams localRequestParams = new RequestParams(); localRequestParams.setHeader("Cookie", hz.a(this.pw)); localRequestParams.addBodyParameter("cmd", "auth.login"); localRequestParams.addBodyParameter("client", "chinamoocs"); localRequestParams.addBodyParameter("user", str1); localRequestParams.addBodyParameter("password", (String)localObject1); Object localObject2 = new ArrayList(); ((List)localObject2).add("auth.login"); ((List)localObject2).add("chinamoocs"); ((List)localObject2).add(str1); ((List)localObject2).add(localObject1); ((List)localObject2).add("xF3m1m4CrvQd3VsfsEpIf6s0CPWT7sJu"); localObject1 = ""; try &#123; localObject2 = ig.d((List)localObject2); localObject1 = localObject2; &#125; catch (Exception localException) &#123; for (;;) &#123;&#125; &#125; localRequestParams.addBodyParameter("sign", ((String)localObject1).toLowerCase()); new HttpUtils().send(HttpRequest.HttpMethod.POST, paramString, localRequestParams, new RequestCallBack() &#123; public void onFailure(HttpException paramAnonymousHttpException, String paramAnonymousString) &#123; Toast.makeText(UnifyLucherActivity.this, "获取认证信息失败...", 0).show(); UnifyLucherActivity.a(UnifyLucherActivity.this).ed(); &#125; public void onStart() &#123; UnifyLucherActivity.a(UnifyLucherActivity.this).m(UnifyLucherActivity.this, "正在认证，请稍后..."); &#125; public void onSuccess(ResponseInfo&lt;String&gt; paramAnonymousResponseInfo) &#123; hz.a(paramAnonymousResponseInfo, UnifyLucherActivity.a(UnifyLucherActivity.this)); try &#123; Object localObject1 = new org/json/JSONObject; ((JSONObject)localObject1).&lt;init&gt;((String)paramAnonymousResponseInfo.result); Object localObject2 = ((JSONObject)localObject1).optString("code"); paramAnonymousResponseInfo = ((JSONObject)localObject1).optString("message", "服务器或网络出现错误，请稍后再试~"); if ("000000".equals(localObject2)) &#123; localObject2 = ((JSONObject)localObject1).getJSONObject("result"); paramAnonymousResponseInfo = ((JSONObject)localObject2).optString("data"); localObject1 = ((JSONObject)localObject2).optString("from"); localObject2 = ((JSONObject)localObject2).optString("key"); UnifyLucherActivity.a(UnifyLucherActivity.this, str1, str2, UnifyLucherActivity.b(UnifyLucherActivity.this), paramString, paramAnonymousResponseInfo, (String)localObject1, (String)localObject2); &#125; for (;;) &#123; UnifyLucherActivity.a(UnifyLucherActivity.this).ed(); return; Toast.makeText(UnifyLucherActivity.this, paramAnonymousResponseInfo, 0).show(); UnifyLucherActivity.a(UnifyLucherActivity.this).ed(); &#125; &#125; catch (JSONException paramAnonymousResponseInfo) &#123; for (;;) &#123; paramAnonymousResponseInfo.printStackTrace(); Toast.makeText(UnifyLucherActivity.this, "认证解析出错...", 0).show(); UnifyLucherActivity.a(UnifyLucherActivity.this).ed(); &#125; &#125; &#125; &#125;); &#125; 继续追踪函数进行分析 , 静态分析发现 aF 是一个 DESede (3DES) 的对称算法 其中 , 发现 3DES 的密匙存放于一个字节数组 zC 1static final byte[] zC = &#123; 14, -74, 79, 26, 2, -3, 88, 121, 25, -83, 84, 52, 13, 61, -101, 1, 42, 25, 19, 70, 124, -95, -50, 44 &#125;; 随后我们使用 Python 进行测试 , 通过解密验证 其中由于 Python 和 Java 的 byte[] 不一样 , 我们将 zC 转换成了 Base64 字符串 DrZPGgL9WHkZrVQ0DT2bASoZE0Z8oc4s , 并在解密的时候再解码使用 123456789101112131415import base64import pyDesdef pwd_encrypt(password): key = "DrZPGgL9WHkZrVQ0DT2bASoZE0Z8oc4s" key = base64.standard_b64decode(key) k = pyDes.triple_des(key, pyDes.ECB, IV=None, pad=None, padmode=pyDes.PAD_PKCS5) d = k.encrypt(password) res = base64.b64encode(d) return bytes.decode(res, "utf8")print(pwd_encrypt("your password")) 注意记得安装第三方库 pyDes 1pip install pyDes 至此整个过程结束 , 一份名华慕课的工具在我的 GitHub 需要的可以自行 git 总结通过逆向过程我们发现名华慕课的安卓客户端没有 release 版本进行加密、函数混淆或对加密的函数使用so调用 , 这是不符合产品安全规范的]]></content>
      <categories>
        <category>Disassembler</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云音乐 Web 登录算法解密过程分析以及实现]]></title>
    <url>%2F2018%2F12%2F15%2F1544852143%2F</url>
    <content type="text"><![CDATA[测试环境 Ubuntu 18.10 x64 软件环境 Chrome 71.0.3578.98 近期需要对网易云音乐的登录和评论点赞功能做一些工具类的软件，记录一下网易云音乐API的解密过程和实现方法 登录分析首先使用浏览器打开 网易云音乐 抓包打开网易云音乐后 点击右上角登录 -&gt; 使用手机号登录，此时按下F12，打开开发者工具，并切换到 Network 输入自己的网易云音乐账号，得到登录的包（为了方便测试，密码可以输错） 如图，登录时向 https://music.163.com/weapi/login/cellphone?csrf_token= 提交了两个字段 params、encSecKey 猜测 encSecKey 为 params 的解密密匙 寻找 encSecKey 算法在开发者工具切换到 Sources 右键 Top 后点击 Search in all files 随后输入 encSecKey 搜索结果中，只有一个js包含了encSecKey https://s3.music.126.net/web/s/core_db15e45072c12697d6fed065e7a71f62.js 静态分析算法从搜索结果中，定位到88行和90行，将其格式化后 88行：123456789101112131415161718192021222324252627282930313233343536373839404142!function() &#123; function a(a) &#123; var d, e, b = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", c = ""; for (d = 0; a &gt; d; d += 1) e = Math.random() * b.length, e = Math.floor(e), c += b.charAt(e); return c &#125; function b(a, b) &#123; var c = CryptoJS.enc.Utf8.parse(b), d = CryptoJS.enc.Utf8.parse("0102030405060708"), e = CryptoJS.enc.Utf8.parse(a), f = CryptoJS.AES.encrypt(e, c, &#123; iv: d, mode: CryptoJS.mode.CBC &#125;); return f.toString() &#125; function c(a, b, c) &#123; var d, e; return setMaxDigits(131), d = new RSAKeyPair(b, "", c), e = encryptedString(d, a) &#125; function d(d, e, f, g) &#123; var h = &#123;&#125;, i = a(16); return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h &#125; function e(a, b, d, e) &#123; var f = &#123;&#125;; return f.encText = c(a + e, b, d), f &#125; window.asrsea = d, window.ecnonasr = e&#125; (); 90行：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748(function() &#123; var c9h = NEJ.P, er2x = c9h("nej.g"), v9m = c9h("nej.j"), j9a = c9h("nej.u"), RQ5V = c9h("nm.x.ek"), l9c = c9h("nm.x"); if (v9m.bl0x.redefine) return; window.GEnc = true; var brK2x = function(cxx7q) &#123; var m9d = []; j9a.be0x(cxx7q, function(cxv7o) &#123; m9d.push(RQ5V.emj[cxv7o]) &#125;); return m9d.join("") &#125;; var cxt7m = v9m.bl0x; v9m.bl0x = function(Y0x, e9f) &#123; var i9b = &#123;&#125;, e9f = NEJ.X(&#123;&#125;, e9f), mt4x = Y0x.indexOf("?"); if (window.GEnc &amp;&amp; /(^|\.com)\/api/.test(Y0x) &amp;&amp; !(e9f.headers &amp;&amp; e9f.headers[er2x.Ae0x] == er2x.Hb2x) &amp;&amp; !e9f.noEnc) &#123; if (mt4x != -1) &#123; i9b = j9a.hg3x(Y0x.substring(mt4x + 1)); Y0x = Y0x.substring(0, mt4x) &#125; if (e9f.query) &#123; i9b = NEJ.X(i9b, j9a.fR2x(e9f.query) ? j9a.hg3x(e9f.query) : e9f.query) &#125; if (e9f.data) &#123; i9b = NEJ.X(i9b, j9a.fR2x(e9f.data) ? j9a.hg3x(e9f.data) : e9f.data) &#125; i9b["csrf_token"] = v9m.gR2x("__csrf"); Y0x = Y0x.replace("api", "weapi"); e9f.method = "post"; delete e9f.query; var bVs1x = window.asrsea(JSON.stringify(i9b), brK2x(["流泪", "强"]), brK2x(RQ5V.md), brK2x(["爱心", "女孩", "惊恐", "大笑"])); e9f.data = j9a.cB0x(&#123; params: bVs1x.encText, encSecKey: bVs1x.encSecKey &#125;) &#125; cxt7m(Y0x, e9f) &#125;; v9m.bl0x.redefine = true&#125;)(); 静态分析后，90行处的代码只是进行了简单的赋值，params由bVs1x.encText而来，encSecKey由bVs1x.encSecKey而来，在88行处，可以看到加密的方式算法和过程，因此88行作为我们的突破口 根据 encSecKey 为关键字寻找，发现在 function d 对其进行了赋值 function d:12345678function d(d, e, f, g) &#123; var h = &#123;&#125;, i = a(16); return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h &#125; 其中分别调用了 function a,b,c 逐一静态分析各个 function function a:12345678function a(a) &#123; var d, e, b = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", c = ""; for (d = 0; a &gt; d; d += 1) e = Math.random() * b.length, e = Math.floor(e), c += b.charAt(e); return c &#125; function a 随机生成一个长度为传入 int 值的字符串 function b:12345678910function b(a, b) &#123; var c = CryptoJS.enc.Utf8.parse(b), d = CryptoJS.enc.Utf8.parse("0102030405060708"), e = CryptoJS.enc.Utf8.parse(a), f = CryptoJS.AES.encrypt(e, c, &#123; iv: d, mode: CryptoJS.mode.CBC &#125;); return f.toString() &#125; 从调用的关键字来看，这是一个有关AES的对称加密算法，模式为CBC，iv(向量)为d，也就是“0102030405060708” function c:123456function c(a, b, c) &#123; var d, e; return setMaxDigits(131), d = new RSAKeyPair(b, "", c), e = encryptedString(d, a) &#125; 静态分析来看，这是一个有关于 RSA 的参数，接下来我们使用断点动态分析加密函数 断点调试算法在下图几个地方打上断点 打上了断点以后我们再一次点击登录 看到js运行到断点时，停止了，第个断点处，传入了参数 a:16 生成一个16位的字符串 运行到第二个断点时，传入参数 c : “fAY0MsZsT3WA0eXg” 这是AES的加密密匙 运行到第三个断点时，传入参数 b : “0CoJUm6Qyw8W8jud” 和一串json a(登录信息) 运行到第四个断点时，传入参数 b : “fAY0MsZsT3WA0eXg”（AES密匙）和一串Base64字符串:12a : &quot;2pi8lzed+/YUH63EXHn6d9IwIDeruHJmzW0rjEtUqUh00G+8ElR2XnxRvDOg+eWHcO06ukSrADFNFazIhKGNMJ/fYDsS2bTep4lkTxH42fLDCPm/v+Z/7P3guz9HcZWwNQ1Y1qb2pUNt1nmGpR89n+MiPQb3gbOscmJPXf8V60kDuLF0u0dwHkeqD5hIhgqRa3qZJCeYZcU3GrAEABFMe/cNhfcrUHpGgTOB4JJw==&quot;(为了保护信息，已经对这里的字符串a进行了删减) 运行到第五个断点时，RSA的加密函数，传入了: 123a : &quot;fAY0MsZsT3WA0eXg&quot;（AES密匙）b : &quot;010001&quot;C : &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot; 第一次断点结束后，我们再点击一次登录，再次进行一次断点调试，通过第二次断点调试，发现第三次断点时的传入参数 b 和 第五个断点时的参数 b c 是不变的，分别为 1234b = &quot;0CoJUm6Qyw8W8jud&quot; #第三次断点参数 b--- 第五次断点 ---b = &quot;010001&quot;c = &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot; 动静结合分析算法根据 function d :12345678function d(d, e, f, g) &#123; var h = &#123;&#125;, i = a(16); return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h &#125; 在 var h = {}, 处断点 得到d,e,f,g的值 可以看到1234d = json a(登录信息) e = &quot;010001&quot; f = &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot;g = &quot;0CoJUm6Qyw8W8jud&quot; 将参数放入 function d 中，首先是使用第一个密匙”0CoJUm6Qyw8W8jud”对 JSON 登录信息的字符串进行了一次 AES 加密，随后得到的结果，在使用通过 function a 生成的16位字符作为AES的加密密匙对第一次AES加密的json的登录信息结果，再次加密，而得出的加密结果就作为 encText，也就是整个加密的流程为： 验证算法在摸清了整个算法流程以后，我们使用AES在线加解密，将加密结果解密，看是否能得到最初的json登录信息，只需要params的值 使用生成的密匙进行第一次解密 params 第一次解密后，我们仍然得到了一串Base64字符串，别着急，在使用默认的密匙”0CoJUm6Qyw8W8jud”对结果进行再次解密 此时已经得到了登录信息的 json 字符串 至此，整个网易云登录的算法分析到此结束 Python 实现登录 Python 3.6.7 pip 18.1 安装第三方库123$ sudo pip install requests$ sudo pip install pycrypto$ sudo pip install future 编写加密函数首先引用 AES 的默认密匙和 RSA 的 MODULUS 和 Pub_Key 1234567MODULUS = ('00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7' 'b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280' '104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932' '575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b' '3ece0462db0a22b8e7')nonce = b'0CoJUm6Qyw8W8jud'pub_key = '010001' 生成随机密匙12def create_secret_key(size): return binascii.hexlify(os.urandom(size))[:16] # 使用库 binascii AES 加密123456def aes_encrypt(text, sec_key): pad = 16 - len(text) % 16 text = text + bytearray([pad] * pad) encryptor = AES.new(sec_key, 2, b'0102030405060708') ciphertext = encryptor.encrypt(text) return base64.b64encode(ciphertext) RSA 加密 RSA 加密采用非常规填充方式，既不是PKCS1也不是PKCS1_OAEP，网易的做法是直接向前补0 这样加密出来的密文有个特点：加密过程没有随机因素，明文多次加密后得到的密文是相同的 算法选取2个很大的质数p,q，得到它们的乘积n，然后选取e,d满足e*d = 1 mod (p-1)(q-1) 因此 RSA 的加密算法应该为 12345def rsa_encrypt(text, pub_key, modulus): text = text[::-1] rs = pow(int(binascii.hexlify(text), 16), int(pub_key, 16), int(modulus, 16)) return format(rs, 'x').zfill(256) 组合登录123456789101112131415161718def login_cell_phone(number,password): md_create = hashlib.md5() md_create.update(password.encode('utf-8')) #计算密码的md5 text = &#123; 'phone': number, 'password': md_create.hexdigest(), 'rememberLogin': 'true' &#125; text = json.dumps(text).encode('utf-8') #获取 JSON 字符串 sec_key = create_secret_key(16) #第二次加密使用的密匙 result = aes_encrypt(text, nonce) #第一次使用默认密匙加密的结果 enc_text = aes_encrypt(result, sec_key) #加密第一次的结果为params enc_sec_key = rsa_encrypt(sec_key, pub_key, MODULUS) data = &#123; 'params': enc_text, 'encSecKey': enc_sec_key &#125; response = requests.post('https://music.163.com/weapi/login/cellphone', data=data) 这样一看是没有问题了，可是当Run时，返回的登录结果为 {“code”:-460,”msg”:”Cheating”} 是因为缺少了 Headers ，因此添加一个 Headers 并修改为 123456789101112131415161718192021222324header = &#123; 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'&#125;def login_cell_phone(number,password): md_create = hashlib.md5() md_create.update(password.encode('utf-8')) #计算密码的md5 text = &#123; 'phone': number, 'password': md_create.hexdigest(), 'rememberLogin': 'true' &#125; text = json.dumps(text).encode('utf-8') #获取 JSON 字符串 sec_key = create_secret_key(16) #第二次加密使用的密匙 result = aes_encrypt(text, nonce) #第一次使用默认密匙加密的结果 enc_text = aes_encrypt(result, sec_key) #加密第一次的结果为params enc_sec_key = rsa_encrypt(sec_key, pub_key, MODULUS) data = &#123; 'params': enc_text, 'encSecKey': enc_sec_key &#125; response = requests.post('https://music.163.com/weapi/login/cellphone', data=data, headers=header) obj = json.loads(response.text) print(str(obj["profile"]["nickname"]) + " Login success !") 此时，当账户密码正确时就能返回登录账号的信息了 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import base64import binasciiimport hashlibimport jsonimport osimport requestsfrom Crypto.Cipher import AESfrom future.builtins import int, powMODULUS = ('00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7' 'b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280' '104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932' '575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b' '3ece0462db0a22b8e7')header = &#123; 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'&#125;nonce = b'0CoJUm6Qyw8W8jud'pub_key = '010001'def rsa_encrypt(text, pub_key, modulus): text = text[::-1] rs = pow(int(binascii.hexlify(text), 16), int(pub_key, 16), int(modulus, 16)) return format(rs, 'x').zfill(256)def create_secret_key(size): return binascii.hexlify(os.urandom(size))[:16]def aes_encrypt(text, sec_key): pad = 16 - len(text) % 16 text = text + bytearray([pad] * pad) encryptor = AES.new(sec_key, 2, b'0102030405060708') ciphertext = encryptor.encrypt(text) return base64.b64encode(ciphertext)def login_cell_phone(number,password): md_create = hashlib.md5() md_create.update(password.encode('utf-8')) # 计算密码的md5 text = &#123; 'phone': number, 'password': md_create.hexdigest(), 'rememberLogin': 'true' &#125; text = json.dumps(text).encode('utf-8') # 获取 JSON 字符串 sec_key = create_secret_key(16) # 第二次加密使用的密匙 result = aes_encrypt(text, nonce) # 第一次使用默认密匙加密的结果 enc_text = aes_encrypt(result, sec_key) # 加密第一次的结果为params enc_sec_key = rsa_encrypt(sec_key, pub_key, MODULUS) data = &#123; 'params': enc_text, 'encSecKey': enc_sec_key &#125; response = requests.post('https://music.163.com/weapi/login/cellphone', data=data, headers=header) obj = json.loads(response.text) print(str(obj["profile"]["nickname"]) + " Login success !") print(response.text)login_cell_phone('your_number','your_password')]]></content>
      <categories>
        <category>Disassembler</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>算法</tag>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Frp 内网穿透配置和客户端自启]]></title>
    <url>%2F2018%2F12%2F14%2F1544801182%2F</url>
    <content type="text"><![CDATA[客户端环境 Ubuntu 18.10 x64 服务端环境 CentOS 7.4 x64 Git 2.19.1 安装 FRP到 Frp 官方GitHub下载 Release 解压安装 或者使用Git 克隆项目1$ git clone https://github.com/fatedier/frp.git 注意下载对应的处理器版本 部署 FRP将下载的 Release 解压得到如下文件 frpc 为客户端的文件, frps 为服务端的文件 将frps.*的文件上传到服务器，frpc.*的文件部署到客户端，为了避免文件缺失，可以全部文件部署到服务端和客户端 Frps 服务端配置编辑 frps.ini 文件 1$ vi frps.ini 进行如下配置12345678910[common]bind_port = 7000 # Frps 的端口bind_addr = 0.0.0.0 # Fprs 使用的IP地址vhost_http_port = 8080 # 自定义的http访问地址bind_udp_port = 7007 # Frps 绑定的UDP协议地址token = your_token # 客户端连接 Fprs 的凭据dashboard_port = 70 # Frps Web 管理面板的端口dashboard_user = your_user # Frps Web 管理面板的管理员账号dashboard_pwd = your_password # Frps Web 管理面板的管理员密码dashboard_addr = 0.0.0.0 # Frps Web 管理面板使用的IP地址 启动 Frps配置完成后,启动Frps12$ chmod a+x frps$ ./frps -c fprs.ini 当看到如下图时,说明Frps启动完成 Frpc 客户端配置编辑 frpc.ini 文件1$ vi frpc.ini 进行如下配置 12345678910[common]server_addr = your_server_ip # Frps 部署的服务端IP server_port = 7000 # Frps 运行的端口token = your_token # Frps 连接的凭据[ssh-Desktop] # 连接的label 用于服务端管理和区分type = tcp # 连接类型local_ip = 127.0.0.1 # 本地的IPlocal_port = 22 # SSH 的本地运行端口remote_port = 6666 # 远程访问的端口 启动 Frpc12$ chmod a+x frpc$ ./frpc -c frpc.ini 当看到下图时,说明Frpc启动完成 设置 Frpc 自启动脚本以 Ubuntu 为例设置Frpc的脚本，网上的教程或者一键脚本可能启动后并不能成功的连接到Frps，可能是网卡还没有初始化导致，使用延迟的方法，在生产环境中十分影响效率，因此这里使用ping来判断网络是否连接，并连接到Frps 12$ cd /etc/init.d$ sudo vi frpc 将下面内容写入到 frpc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/bin/sh ### BEGIN INIT INFO# Provides: frpc# Required-Start: $local_fs $remote_fs $network $syslog# Required-Stop: $local_fs $remote_fs $network $syslog# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: start/stop frpc# Description: starts frpc using start-stop-daemon### END INIT INFOSTART=50PIDF=` ps -A | grep frpc | awk '&#123;print $1&#125;'`case "$1" in start) i=0 while [ $i -le 0 ] do ping -c 1 你的服务器IP &gt; /dev/null 2&gt;&amp;1 if [ $? -eq 0 ];then rm -rf /opt/frp/frpc.log #frpc的日志路径 touch /opt/frp/frpc.log #frpc的日志路径 nohup /opt/frp/frpc -c /opt/frp/frpc.ini &gt; /dev/null 2&gt;&amp;1 &amp; #frpc的启动路径和配置文件路径 break else echo "网络异常无法启动frpc" fi done echo "frpc启动完成" ;;stop) kill -3 $PIDF rm -rf /opt/frp/frpc.log #frpc的日志路径 touch /opt/frp/frpc.log #frpc的日志路径 echo "frpc已经关闭" ;;restart) $0 stop sleep 1 $0 start ;;status) ps -fe|grep /opt/frp/frpc.ini |grep -v grep #frpc的启动路径和配置文件路径 if [ $? -ne 0 ] then echo "frpc未启动" else echo "frpc已启动" cat /opt/frp/frpc.log #frpc的日志路径 fi ;;esac 将上面内容替换成Frps的IP和Frpc的路径，保存 12$ sudo chmod a+x frpc$ sudo systemctl enable frpc.service 这样一来，就可以在开机的时候顺利的连接到frps了 查看 Frps Web 面板在浏览器输入 server_ip:port ，然后输入设置的面板管理账户登录到面板 然后在 Proxies 中选择连接类型来查看已经连接的客户端信息]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>Frp</tag>
      </tags>
  </entry>
</search>
